# Task 1

## 1.八种数据基本类型

1. 整型：byte,short,int,long
2. 字符型：char
3. 浮点型：float，double
4. 布尔型：boolean

## 2.

## 四种整型数据类型占用的字节数和表示范围

1. byte：
   1. 占用字节数：1
   2. 表示范围：-128-127
2. short：
   1. 占用字节数：2
   2. 表示范围：-32768-32767
3. int：
   1. 占用字节数：4
   2. 表示范围：-2147483648-2147483647
4. long：
   1. 占用字节数：8
   2. 表示范围：-9223372036854775808-9223372036854775807

## 自动类型转换和强制类型转换

自动类型转换是自动完成的，不需要命令处理，不同数据类型相加时，范围较小的数据类型自动转到范围较大的数据类型。或精度较低的数据（如整型）自动转到精度较高的数据（如浮点型）。

强制类型转换不能自动完成，需要进行命令控制，用来将范围较大的数据类型转到范围较小的数据类型。

需要注意：强制类型转换可能出现精度损失（浮点型强制转为整型）或数据溢出（超过了小范围数据类型的数据范围导致溢出到符号位正负号变化或溢出更多位）。

## 3.

涉及到的是自动类型转换，char类型在运算时自动转到int类型进行运算。

b的值是52.

因为char类型自动转到int类型，且转换为相应的ASCII值。输出为int，则只需将int类型的a与char类型的c的ASCII值（48）相加即为输出值。

## 4.

### 输出结果：

false

true

false

### 原因：

1. x与y：

   integer是int的包装类，定义的是引用类型变量，当比较时，比较的是它们的引用地址，而在新建一个integer时，生成了新的指针指向18，引用地址不同，因此判定x不等于y。

2. z与k：

   都是非新建的integer，都指向java常量池中的对象，且18在-128-127之间，java已经进行了缓存，因此比较结果为true。

3. m与p：

   虽然都是非新建的integer，但是300不在-128-127的范围之内，java未对其进行缓存，比较结果为false。

# Task 2

## 5.

### 结果：

13

6 8

### 计算过程：

13：

1. 先计算小括号中的内容
2. ++a：自增a，先加一再引用a，自增表达式的值等于a自增后的值6
3. b++：b自增，先引用b再加一，自增表达式的值等于b自增前的值7
4. 6+7=13

6 8：

1. ++a：自增a，a的值变为6
2. b++：b自增，b的值变为8
3. “”是空字符串
4. 当用+连接字符串与其他数据类型时，会将其他类型先自动转型为字符串再连接
5. 输出6 8

## 6.

a=0010

-a=1010

a&（-a）=0010

对于任意非负整数a，a&（-a）=a

因为符号位变化，a符号位为0，-a符号位为1，&运算后结果为0，结果是正数；

而其它位上a与-a相同，因此&计算后依然与a相同。

因此a&（-a）=a。

