# 基础部分



参考教程：[【Socket】Java Socket编程基础及深入讲解 - 已往之不谏 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yiwangzhibujian/p/7107785.html)

遇到的问题：

1. 字节流无法直接应用于BufferedReader，需要转换；

   解决：参考[Java基础之将InputStream转换为Reader_inputstream转reader-CSDN博客](https://blog.csdn.net/bobbyliang/article/details/107741244)，将Inputstream转换为Reader

2. 不理解clienthandler的作用；

   解决：似乎是用来控制多线程的

3. 连接成功，但是客户端键入的信息在服务器端不显示

   解决：在循环内部调用tellEveryone

4. 显示出null

   发现问题：循环中一直没有输出过发送提示，也就是信息没有传到服务器

   解决：直接调用tellEveryone，不通过实例调用

5. 一直报Exception in thread "main" java.net.SocketException: Socket is closed

   解决：参考[JAVA——TCP连接中Socket的正确关闭方式_java tcp 正确关闭-CSDN博客](https://blog.csdn.net/weixin_43272781/article/details/103231958)正确关闭socket

6. 客户端按预想的运行，但服务器端没有任何输出

   解决：找到问题：客户端在输入时没有换行符，而readline方法遇到换行符才会有结果，添加换行符后成功输出

# 附加部分：

1. 进程内存独立不共享
2. 线程的堆内存和方法区共享，但栈内存独立
3. 线程对象的生命周期
   1. 新建状态
   2. 就绪状态：可运行，具有抢夺CPU时间片的权利
   3. 运行状态：占有CPU时间片
   4. 阻塞状态：放弃占有的CPU时间片
   5. 死亡状态
4. 数据安全问题的解决：线程同步（排队）-占有、释放锁
5. 局部变量在栈中，永远不会共享

遇到的问题：

1. 一开始的思路是在两边各建立一条TCP连接，通过不同的TCP连接在不同的线程上同时发送和接受消息，但是很快发现这样两边必有一方先运行，那么后运行的一方作为服务器晚于客户端启动，导致依然只能实现单方向通信
2. 改变思路，只用一条TCP连接

# 附加题改

思路：实现多人同时在线聊天，通过服务器把各人信息传送到所有人处

